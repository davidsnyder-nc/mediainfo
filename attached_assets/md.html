<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Dashboard</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e67e22;
            --bg-color: #f4f7f9;
            --card-bg-color: #ffffff;
            --text-color: #333;
            --muted-text-color: #7f8c8d;
            --border-color: #e0e0e0;
            --success-color: #2ecc71;
            --error-color: #e74c3c;
            --warning-color: #f39c12;
            --info-color: #3498db; /* For info toasts */
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            font-family: var(--font-family);
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .floating-action-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column; /* Stack icons vertically */
            gap: 10px; /* Space between icons */
        }

        .settings-icon-btn, .pushover-history-btn, .scroll-page-btn {
            background: var(--card-bg-color);
            border: 1px solid var(--border-color);
            color: var(--secondary-color);
            cursor: pointer;
            padding: 0;
            width: 50px;
            height: 50px;
            min-width: 50px;
            min-height: 50px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
        }
        .settings-icon-btn svg, .pushover-history-btn svg, .scroll-page-btn svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
        .settings-icon-btn:hover, .pushover-history-btn:hover, .scroll-page-btn:hover {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }


        .main-container {
            flex-grow: 1;
            padding: 20px;
            padding-bottom: 90px;
            display: block;
            overflow-y: auto;
        }
        .settings-container {
            flex-grow: 1;
            padding: 20px;
            padding-bottom: 90px;
            display: none;
            overflow-y: auto;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        @media (min-width: 900px) {
            .settings-grid {
                grid-template-columns: repeat(2, 1fr);
            }
             .settings-group.full-width-setting {
                grid-column: 1 / -1;
            }
            .settings-grid > .settings-group:last-child:nth-child(odd) {
                grid-column: 1 / -1;
            }
        }


        .container-title {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .service-cards-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-start;
        }

        .service-card {
            background-color: var(--card-bg-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            padding: 20px;
            flex: 1 1 320px;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .service-card .card-content-wrapper {
            padding-right: 5px;
            flex-grow: 1;
            min-height: 0;
        }


        .service-card h2 {
            margin-top: 0;
            color: var(--secondary-color);
            font-size: 1.5em;
            border-bottom: none;
            padding-bottom: 10px;
            display: inline-block;
            margin-right: 0;
        }

        .settings-group {
            background-color: var(--card-bg-color);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .settings-group h3 {
            margin-top: 0;
            color: var(--secondary-color);
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 8px;
            display: flex;
            align-items: center;
        }
        .settings-group h3 svg {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            fill: var(--secondary-color);
            flex-shrink: 0;
        }
        .settings-group p.note {
            font-size: 0.85em;
            color: var(--muted-text-color);
            margin-top: -10px;
            margin-bottom: 10px;
        }
        .toggle-switch-label {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }
        .toggle-switch-label input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
            height: 1.2em;
            width: 1.2em;
            cursor: pointer;
        }


        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        input[type="text"], input[type="password"], input[type="url"], select {
            width: calc(100% - 24px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 1em;
            background-color: white;
        }
        input:focus, select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
            outline: none;
        }
        select {
             width: 100%;
        }


        button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:active {
            transform: translateY(1px);
        }
        button.secondary { background-color: var(--muted-text-color); }
        button.secondary:hover { background-color: #6c7a7d; }
        button.danger { background-color: var(--error-color); }
        button.danger:hover { background-color: #c0392b; }
        .load-more-btn {
            display: block;
            margin: 15px auto 0;
            width: auto;
        }

        .item-list { list-style-type: none; padding: 0; }

        .sab-item, .calendar-item {
            background-color: #f9f9f9;
            border: 1px solid var(--border-color);
            padding: 12px 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            transition: box-shadow 0.2s ease;
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }
        .sab-item:hover, .calendar-item:hover {
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        }
        .item-content {
            flex-grow: 1;
            min-width: 0;
        }
        .item-title-main {
            font-weight: 600;
            color: var(--secondary-color);
            margin-bottom: 5px;
            word-break: break-all;
            white-space: normal;
        }
        .item-meta-info {
            font-size: 0.85em; color: var(--muted-text-color);
        }
        .calendar-item-date {
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 3px;
            font-size: 0.9em;
        }
        .calendar-item-poster {
            width: 50px;
            height: 75px;
            object-fit: cover;
            border-radius: 4px;
            flex-shrink: 0;
            background-color: #eee;
        }
        .calendar-episode-summary {
            font-size: 0.9em;
            margin-left: 10px;
            padding-top: 3px;
            color: var(--text-color);
        }
        .scroll-indicator-container { /* Wrapper for scroll indicator */
            position: absolute;
            bottom: 5px; /* Position relative to the card bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background-color: rgba(44, 62, 80, 0.1); /* Faint circle using secondary color */
            border-radius: 50%;
            display: none; /* Hidden by default, shown by JS */
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        .scroll-indicator-container svg {
            width: 20px;
            height: 20px;
            fill: var(--secondary-color); /* Darker icon for better visibility */
            opacity: 0.6;
        }


        .plex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
            padding: 0;
            list-style-type: none;
        }
        .plex-item {
            background-color: var(--card-bg-color);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .plex-item-poster {
            width: 100%;
            height: auto;
            aspect-ratio: 2 / 3;
            object-fit: cover;
            display: block;
            border-bottom: 1px solid var(--border-color);
        }
        .plex-item-info {
            padding: 8px 10px;
            background-color: rgba(255,255,255,0.95);
            min-height: 50px;
        }
        .plex-item-title {
            font-weight: 600;
            font-size: 0.85em;
            line-height: 1.3;
            color: var(--secondary-color);
            margin-bottom: 4px;
            white-space: normal;
            overflow-wrap: break-word;
            max-height: 2.6em;
        }
        .plex-item .progress-bar-container { height: 6px; margin-top: 5px; }
        .plex-item .progress-bar { height: 100%; }
        .plex-item .item-meta { font-size: 0.8em; }

        .message {
            padding: 12px 15px; margin-top: 15px; margin-bottom: 15px;
            border-radius: 6px; text-align: center; font-size: 0.95em;
        }
        .error-message { background-color: var(--error-color); color: white; }
        .loading-message { background-color: var(--warning-color); color: white; }
        .info-message { background-color: var(--info-color); color: white; }
        .success-message { background-color: var(--success-color); color: white; }

        #plexPinSection {
            margin-top: 15px; padding: 15px; border: 1px solid var(--border-color);
            border-radius: 6px; background-color: #f9f9f9;
        }
        #plexPinCode {
            font-size: 2.2em; letter-spacing: 5px; color: var(--accent-color);
            display: block; text-align: center; margin: 10px 0; font-weight: bold;
        }
        #plexPinStatus { margin-top: 10px; font-weight: bold; }

        .config-buttons-footer {
            margin-top: 20px;
            text-align: right;
            grid-column: 1 / -1;
        }

        /* Toast Notifications */
        #toastContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
        }
        .toast {
            background-color: var(--secondary-color);
            color: white;
            padding: 18px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.5s ease, transform 0.5s ease;
            min-width: 300px;
            font-size: 1.05em;
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        .toast.info { background-color: var(--info-color); }
        .toast.success { background-color: var(--success-color); }
        .toast.warning { background-color: var(--warning-color); }
        .toast.error { background-color: var(--error-color); }

        /* Pushover History Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1500;
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .modal-header h3 { margin: 0; color: var(--secondary-color); }
        .modal-close-btn, #clearNotificationHistoryBtn { /* Style clear button like close */
            background: none; border: none; font-size: 1.5em; cursor: pointer;
            color: var(--muted-text-color);
            padding: 0 5px;
        }
        .modal-close-btn:hover, #clearNotificationHistoryBtn:hover { color: var(--error-color); }
        #clearNotificationHistoryBtn { font-size: 0.8em; font-weight:bold; margin-right: auto; }


        .history-item {
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }
        .history-item:last-child { border-bottom: none; }
        .history-item-title { font-weight: bold; }
        .history-item-message { font-size: 0.9em; margin: 5px 0; }
        .history-item-time { font-size: 0.75em; color: var(--muted-text-color); }


        /* Desktop specific scrolling for lists inside cards */
        @media (min-width: 769px) {
            .service-card .card-content-wrapper {
                 max-height: 550px; /* Consistent max height for desktop */
                 overflow-y: auto;
                 scrollbar-width: none; /* Firefox */
                -ms-overflow-style: none;  /* IE and Edge */
            }
            .service-card .card-content-wrapper::-webkit-scrollbar {
                display: none; /* Webkit */
            }
        }


        /* Mobile Accordion Styles */
        @media (max-width: 768px) {
            .service-cards-container { flex-direction: column; }
            .plex-grid {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            }
            .settings-grid { grid-template-columns: 1fr; }

            .service-card .card-content-wrapper {
                display: none;
                padding-top: 10px;
                max-height: none;
                overflow-y: visible;
                padding-right: 0;
            }
            .service-card.expanded .card-content-wrapper {
                display: block;
            }
            .service-card h2 {
                cursor: pointer;
            }
            #sabnzbdList, #sonarrCalendarList,
            #plexList, #plexMoviesList, #plexTvList {
                max-height: none;
                overflow-y: visible;
            }
        }
        @media (max-width: 480px) {
            .settings-icon-btn, .pushover-history-btn, .scroll-page-btn {
                width: 45px; height: 45px;
                padding: 0;
            }
            .settings-icon-btn svg, .pushover-history-btn svg, .scroll-page-btn svg { width: 20px; height: 20px;}
            .settings-icon-btn { bottom: 15px; right: 15px; }
            .pushover-history-btn { bottom: 70px; right: 15px; }
            .scroll-page-btn { bottom: 125px; right: 15px; }


            .main-container, .settings-container { padding-bottom: 80px; }


            .plex-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
            }
            input[type="text"], input[type="password"], input[type="url"], select, button {
                width: 100%; margin-right: 0;
            }
            .plex-item-title {
                font-size: 0.8em;
            }
            .calendar-item-poster {
                width: 40px; height: 60px;
            }
        }
    </style>
</head>
<body>
    <div id="toastContainer"></div>

    <div class="floating-action-buttons">
         <button class="scroll-page-btn" id="scrollPageBtn" title="Scroll Page">
            </button>
        <button class="pushover-history-btn" id="pushoverHistoryBtn" title="Notification History">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z"/>
            </svg>
        </button>
        <button class="settings-icon-btn" id="settingsBtn" title="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.26C14.36,2.02,14.18,1.84,13.94,1.84 h-3.88c-0.24,0-0.43,0.18-0.47,0.42L9.21,4.93C8.62,5.16,8.09,5.48,7.59,5.86L5.2,4.91C4.98,4.83,4.73,4.9,4.61,5.12L2.69,8.44 C2.58,8.64,2.63,8.91,2.81,9.05l2.03,1.58C4.82,10.97,4.8,11.29,4.8,11.62c0,0.32,0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.38,2.67 c0.04,0.24,0.23,0.42,0.47,0.42h3.88c0.24,0,0.43-0.18,0.47-0.42l0.38-2.67c0.59-0.24,1.12-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0.01,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.49-0.12-0.62L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
            </svg>
        </button>
    </div>

     <div id="pushoverHistoryModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Notification History</h3>
                <button id="clearNotificationHistoryBtn" title="Clear History">Clear</button>
                <button class="modal-close-btn" id="closePushoverHistoryModal">&times;</button>
            </div>
            <ul id="pushoverHistoryList" class="item-list">
                </ul>
            <p id="noPushoverHistory" style="display:none; text-align:center; color: var(--muted-text-color);">No notifications yet.</p>
        </div>
    </div>


    <div id="mainView" class="main-container">
        <div id="serviceCardsContainer" class="service-cards-container">
            <div id="sabnzbdCard" class="service-card" data-service-key="sabnzbd" style="display: none;">
                <h2 data-card-title-key="sabnzbd">Downloads</h2>
                <div class="card-content-wrapper">
                    <div id="sabnzbdLoading" class="message loading-message" style="display: none;">Loading...</div>
                    <div id="sabnzbdError" class="message error-message" style="display: none;"></div>
                    <ul id="sabnzbdList" class="item-list"></ul>
                    <button id="showMoreSabnzbdBtn" class="load-more-btn" style="display:none;">Show More Downloads</button>
                </div>
                 <div class="scroll-indicator-container">
                    <svg class="scroll-indicator" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </div>
            </div>

            <div id="plexCard" class="service-card" data-service-key="plex" style="display: none;">
                <h2 data-card-title-key="plex">Continue Watching</h2>
                <div class="card-content-wrapper">
                    <div id="plexLoading" class="message loading-message" style="display: none;">Loading...</div>
                    <div id="plexError" class="message error-message" style="display: none;"></div>
                    <ul id="plexList" class="plex-grid"></ul>
                    <button id="loadMorePlexBtn" class="load-more-btn" style="display:none;">Load All</button>
                </div>
                 <div class="scroll-indicator-container">
                    <svg class="scroll-indicator" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </div>
            </div>

            <div id="plexRecentlyAddedMoviesCard" class="service-card" data-service-key="plexMovies" style="display: none;">
                <h2 data-card-title-key="plexMovies">Recently Added Movies</h2>
                <div class="card-content-wrapper">
                    <div id="plexMoviesLoading" class="message loading-message" style="display: none;">Loading...</div>
                    <div id="plexMoviesError" class="message error-message" style="display: none;"></div>
                    <ul id="plexMoviesList" class="plex-grid"></ul>
                    <button id="loadMorePlexMoviesBtn" class="load-more-btn" style="display:none;">Load All</button>
                </div>
                 <div class="scroll-indicator-container">
                    <svg class="scroll-indicator" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </div>
            </div>

            <div id="plexRecentlyAddedTvCard" class="service-card" data-service-key="plexTv" style="display: none;">
                <h2 data-card-title-key="plexTv">Recently Added TV Shows</h2>
                <div class="card-content-wrapper">
                    <div id="plexTvLoading" class="message loading-message" style="display: none;">Loading...</div>
                    <div id="plexTvError" class="message error-message" style="display: none;"></div>
                    <ul id="plexTvList" class="plex-grid"></ul>
                    <button id="loadMorePlexTvBtn" class="load-more-btn" style="display:none;">Load All</button>
                </div>
                 <div class="scroll-indicator-container">
                    <svg class="scroll-indicator" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </div>
            </div>


            <div id="sonarrCard" class="service-card" data-service-key="sonarr" style="display: none;">
                <h2 data-card-title-key="sonarr">Calendar</h2>
                <div class="card-content-wrapper">
                    <div id="sonarrLoading" class="message loading-message" style="display: none;">Loading...</div>
                    <div id="sonarrError" class="message error-message" style="display: none;"></div>
                    <ul id="sonarrCalendarList" class="item-list"></ul>
                    <button id="loadMoreSonarrBtn" class="load-more-btn" style="display:none;">Load More Days</button>
                </div>
                 <div class="scroll-indicator-container">
                    <svg class="scroll-indicator" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>
                </div>
            </div>
        </div>
         <div id="noServicesConfiguredMessage" class="message info-message" style="display: none;">
            Welcome! Please configure your services via the settings icon to see your media.
        </div>
    </div>

    <div id="settingsView" class="settings-container">
        <h2 class="container-title">Settings</h2>
        <div class="settings-grid">
            <div class="settings-group">
                <h3><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>SABnzbd Configuration</h3>
                <label for="sabnzbdUrl">SABnzbd URL:</label>
                <input type="url" id="sabnzbdUrl" placeholder="http://your-sabnzbd-address">
                <label for="sabnzbdApiKey">SABnzbd API Key:</label>
                <input type="text" id="sabnzbdApiKey" placeholder="Your SABnzbd API Key">
            </div>

             <div class="settings-group">
                <h3><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>Sonarr Configuration</h3>
                <label for="sonarrUrl">Sonarr URL:</label>
                <input type="url" id="sonarrUrl" placeholder="http://your-sonarr-address">
                <label for="sonarrApiKey">Sonarr API Key:</label>
                <input type="text" id="sonarrApiKey" placeholder="Your Sonarr API Key">
            </div>

            <div class="settings-group plex-settings">
                <h3><svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>Plex Configuration</h3>
                <label for="plexUrl">Plex Server URL:</label>
                <input type="url" id="plexUrl" placeholder="http://your-plex-address">
                <input type="hidden" id="plexTokenStore">
                <button id="getPlexPinBtn" class="secondary">Link Plex Account (Get Token)</button>
                <div id="plexPinSection" style="display: none;">
                    <p>1. Go to <a href="https://plex.tv/link" target="_blank" rel="noopener noreferrer">https://plex.tv/link</a></p>
                    <p>2. Enter the PIN below:</p>
                    <strong id="plexPinCode"></strong>
                    <p id="plexPinStatus" class="message info-message" style="display:none;"></p>
                    <button id="cancelPlexPinBtn" class="danger">Cancel Linking</button>
                </div>
                <div id="plexLinkedStatus" class="message" style="display:none;"></div>
                <hr style="margin: 20px 0;">
                 <label class="toggle-switch-label">
                    <input type="checkbox" id="enablePlexMovies"> Enable Recently Added Movies
                </label>
                 <label class="toggle-switch-label">
                    <input type="checkbox" id="enablePlexTv"> Enable Recently Added TV Shows
                </label>
            </div>

            <div class="settings-group">
                <h3><svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>Card Titles</h3>
                <label for="titleSabnzbd">Downloads Card Title:</label>
                <input type="text" id="titleSabnzbd" data-title-key="sabnzbd">
                <label for="titlePlexCW">Continue Watching Card Title:</label>
                <input type="text" id="titlePlexCW" data-title-key="plex">
                <label for="titleSonarr">Calendar Card Title:</label>
                <input type="text" id="titleSonarr" data-title-key="sonarr">
                <label for="titlePlexMovies">Recently Added Movies Title:</label>
                <input type="text" id="titlePlexMovies" data-title-key="plexMovies">
                <label for="titlePlexTv">Recently Added TV Title:</label>
                <input type="text" id="titlePlexTv" data-title-key="plexTv">
            </div>

            <div class="settings-group">
                <h3><svg viewBox="0 0 24 24"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"/></svg>Card Display Order</h3>
                <label for="cardOrder1">First Card:</label>
                <select id="cardOrder1" class="card-order-select">
                    <option value="sabnzbd">Downloads (SABnzbd)</option>
                    <option value="plex">Continue Watching (Plex)</option>
                    <option value="sonarr">Calendar (Sonarr)</option>
                    <option value="plexMovies">Recently Added Movies (Plex)</option>
                    <option value="plexTv">Recently Added TV (Plex)</option>
                </select>

                <label for="cardOrder2">Second Card:</label>
                <select id="cardOrder2" class="card-order-select">
                    <option value="sabnzbd">Downloads (SABnzbd)</option>
                    <option value="plex" selected>Continue Watching (Plex)</option>
                    <option value="sonarr">Calendar (Sonarr)</option>
                    <option value="plexMovies">Recently Added Movies (Plex)</option>
                    <option value="plexTv">Recently Added TV (Plex)</option>
                </select>

                <label for="cardOrder3">Third Card:</label>
                <select id="cardOrder3" class="card-order-select">
                    <option value="sabnzbd">Downloads (SABnzbd)</option>
                    <option value="plex">Continue Watching (Plex)</option>
                    <option value="sonarr" selected>Calendar (Sonarr)</option>
                    <option value="plexMovies">Recently Added Movies (Plex)</option>
                    <option value="plexTv">Recently Added TV (Plex)</option>
                </select>
                 <label for="cardOrder4">Fourth Card:</label>
                <select id="cardOrder4" class="card-order-select">
                    <option value="none">None</option>
                    <option value="sabnzbd">Downloads (SABnzbd)</option>
                    <option value="plex">Continue Watching (Plex)</option>
                    <option value="sonarr">Calendar (Sonarr)</option>
                    <option value="plexMovies" selected>Recently Added Movies (Plex)</option>
                    <option value="plexTv">Recently Added TV (Plex)</option>
                </select>
                <label for="cardOrder5">Fifth Card:</label>
                <select id="cardOrder5" class="card-order-select">
                    <option value="none">None</option>
                    <option value="sabnzbd">Downloads (SABnzbd)</option>
                    <option value="plex">Continue Watching (Plex)</option>
                    <option value="sonarr">Calendar (Sonarr)</option>
                    <option value="plexMovies">Recently Added Movies (Plex)</option>
                    <option value="plexTv" selected>Recently Added TV (Plex)</option>
                </select>
                <div id="cardOrderError" class="message error-message" style="display:none;">Please select a different service for each position (or 'None').</div>
            </div>
             <div class="settings-group full-width-setting">
                <h3><svg viewBox="0 0 24 24"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-2 1H8v-6c0-2.48 1.51-4.5 4-4.5s4 2.02 4 4.5v6z"/></svg>Notification Settings</h3>
                <label class="toggle-switch-label">
                    <input type="checkbox" id="enableNotifications"> Enable In-App Notifications
                </label>
                <button id="testNotificationBtn" class="secondary">Test Notification</button>
            </div>
        </div>

        <div class="config-buttons-footer">
            <button id="saveSettingsBtn">Save & View Dashboard</button>
        </div>
        <div id="globalMessagesSettings" class="message" style="display:none;"></div>
    </div>

    <script>
        // --- Page Views ---
        const mainView = document.getElementById('mainView');
        const settingsView = document.getElementById('settingsView');
        const settingsBtn = document.getElementById('settingsBtn');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        const pushoverHistoryBtn = document.getElementById('pushoverHistoryBtn');
        const pushoverHistoryModal = document.getElementById('pushoverHistoryModal');
        const closePushoverHistoryModalBtn = document.getElementById('closePushoverHistoryModal');
        const pushoverHistoryListEl = document.getElementById('pushoverHistoryList');
        const noPushoverHistoryEl = document.getElementById('noPushoverHistory');
        const clearNotificationHistoryBtn = document.getElementById('clearNotificationHistoryBtn');
        const scrollPageBtn = document.getElementById('scrollPageBtn');
        const scrollUpSvg = '<svg viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/></svg>';
        const scrollDownSvg = '<svg viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z"/></svg>';



        // --- DOM Elements (Inputs) ---
        const sabnzbdUrlInput = document.getElementById('sabnzbdUrl');
        const sabnzbdApiKeyInput = document.getElementById('sabnzbdApiKey');
        const plexUrlInput = document.getElementById('plexUrl');
        const sonarrUrlInput = document.getElementById('sonarrUrl');
        const sonarrApiKeyInput = document.getElementById('sonarrApiKey');
        const enableNotificationsInput = document.getElementById('enableNotifications');
        const testNotificationBtn = document.getElementById('testNotificationBtn');
        const enablePlexMoviesInput = document.getElementById('enablePlexMovies');
        const enablePlexTvInput = document.getElementById('enablePlexTv');

        const getPlexPinBtn = document.getElementById('getPlexPinBtn');
        const plexPinSection = document.getElementById('plexPinSection');
        const plexPinCodeEl = document.getElementById('plexPinCode');
        const plexPinStatusEl = document.getElementById('plexPinStatus');
        const cancelPlexPinBtn = document.getElementById('cancelPlexPinBtn');
        const plexTokenStoreEl = document.getElementById('plexTokenStore');
        const plexLinkedStatusEl = document.getElementById('plexLinkedStatus');

        // Card Order Selects
        const cardOrder1Select = document.getElementById('cardOrder1');
        const cardOrder2Select = document.getElementById('cardOrder2');
        const cardOrder3Select = document.getElementById('cardOrder3');
        const cardOrder4Select = document.getElementById('cardOrder4');
        const cardOrder5Select = document.getElementById('cardOrder5');
        const cardOrderErrorEl = document.getElementById('cardOrderError');
        const cardOrderSelects = [cardOrder1Select, cardOrder2Select, cardOrder3Select, cardOrder4Select, cardOrder5Select];

        // Card Title Inputs
        const titleSabnzbdInput = document.getElementById('titleSabnzbd');
        const titlePlexCWInput = document.getElementById('titlePlexCW');
        const titleSonarrInput = document.getElementById('titleSonarr');
        const titlePlexMoviesInput = document.getElementById('titlePlexMovies');
        const titlePlexTvInput = document.getElementById('titlePlexTv');
        const cardTitleInputs = [titleSabnzbdInput, titlePlexCWInput, titleSonarrInput, titlePlexMoviesInput, titlePlexTvInput];
        const defaultCardTitles = {
            sabnzbd: "Downloads",
            plex: "Continue Watching",
            sonarr: "Calendar",
            plexMovies: "Recently Added Movies",
            plexTv: "Recently Added TV Shows"
        };


        // --- DOM Elements (Data Display) ---
        const serviceCardsContainerEl = document.getElementById('serviceCardsContainer');
        const sabnzbdListEl = document.getElementById('sabnzbdList');
        const plexListEl = document.getElementById('plexList'); // For Continue Watching
        const sonarrCalendarListEl = document.getElementById('sonarrCalendarList');
        const plexMoviesListEl = document.getElementById('plexMoviesList');
        const plexTvListEl = document.getElementById('plexTvList');

        const loadMorePlexBtn = document.getElementById('loadMorePlexBtn');
        const showMoreSabnzbdBtn = document.getElementById('showMoreSabnzbdBtn');
        const loadMoreSonarrBtn = document.getElementById('loadMoreSonarrBtn');
        const loadMorePlexMoviesBtn = document.getElementById('loadMorePlexMoviesBtn');
        const loadMorePlexTvBtn = document.getElementById('loadMorePlexTvBtn');

        const sabnzbdCardEl = document.getElementById('sabnzbdCard');
        const plexCardEl = document.getElementById('plexCard'); // Continue Watching
        const sonarrCardEl = document.getElementById('sonarrCard');
        const plexRecentlyAddedMoviesCardEl = document.getElementById('plexRecentlyAddedMoviesCard');
        const plexRecentlyAddedTvCardEl = document.getElementById('plexRecentlyAddedTvCard');
        const noServicesConfiguredMessageEl = document.getElementById('noServicesConfiguredMessage');

        // --- DOM Elements (Loading/Error Messages) ---
        const sabnzbdLoadingEl = document.getElementById('sabnzbdLoading');
        const sabnzbdErrorEl = document.getElementById('sabnzbdError');
        const plexLoadingEl = document.getElementById('plexLoading');
        const plexErrorEl = document.getElementById('plexError');
        const sonarrLoadingEl = document.getElementById('sonarrLoading');
        const sonarrErrorEl = document.getElementById('sonarrError');
        const plexMoviesLoadingEl = document.getElementById('plexMoviesLoading');
        const plexMoviesErrorEl = document.getElementById('plexMoviesError');
        const plexTvLoadingEl = document.getElementById('plexTvLoading');
        const plexTvErrorEl = document.getElementById('plexTvError');
        const globalMessagesSettingsEl = document.getElementById('globalMessagesSettings');
        var toastContainer = document.getElementById('toastContainer');


        // --- Plex PIN Auth State ---
        const X_PLEX_PRODUCT_NAME = "Media Dashboard MinApp";
        let plexClientIdentifier = '';
        let currentPlexPinId = null;
        let plexPollingIntervalId = null;
        let plexPollingTimeoutId = null;
        const PLEX_POLLING_INTERVAL = 5000;
        const PLEX_POLLING_TIMEOUT_DURATION = 3 * 60 * 1000;
        const AUTO_REFRESH_INTERVAL = 5 * 60 * 1000;
        let autoRefreshTimerId = null;

        // --- App State ---
        let currentView = 'main';
        const serviceCardElements = {
            sabnzbd: sabnzbdCardEl,
            plex: plexCardEl,
            sonarr: sonarrCardEl,
            plexMovies: plexRecentlyAddedMoviesCardEl,
            plexTv: plexRecentlyAddedTvCardEl
        };
        const defaultCardOrder = ['sabnzbd', 'plex', 'sonarr', 'plexMovies', 'plexTv'];

        let plexOnDeckData = { items: [], showingAll: false }; // Simplified for single user
        const PLEX_INITIAL_DISPLAY_COUNT = 6; // Applies to all Plex lists now

        let plexRecentlyAddedMoviesData = { items: [], showingAll: false };
        let plexRecentlyAddedTvData = { items: [], showingAll: false };


        let sabnzbdCurrentPageStart = 0;
        const SABNZBD_ITEMS_PER_PAGE = 10;
        let allFetchedSabnzbdSlots = [];
        let lastSeenSabnzbdItemSignature = null;
        let isInitialSabnzbdFetch = true;


        let allFetchedSonarrEpisodes = [];
        let showingAllSonarrEpisodes = false;
        let pushoverMessagesHistory = [];
        let lastSeenPlexMovieItemSignature = null;
        let lastSeenPlexTvShowItemSignature = null;
        let isInitialPlexMoviesFetch = true;
        let isInitialPlexTvFetch = true;


        // --- Navigation ---
        function showView(viewName) {
            if (viewName === 'settings') {
                mainView.style.display = 'none';
                settingsView.style.display = 'block';
                currentView = 'settings';
                loadCardOrderSettings();
                loadCardTitleSettings();
                if (autoRefreshTimerId) clearInterval(autoRefreshTimerId);
            } else {
                mainView.style.display = 'block';
                settingsView.style.display = 'none';
                currentView = 'main';
                applyCardOrderToDOM();
                applyCardTitlesToDOM();
                handleFetchData(false, true);
                startAutoRefresh();
                initializeMobileAccordion();
                updateScrollButtonIcon();
            }
        }

        settingsBtn.addEventListener('click', () => {
            if (currentView === 'settings') {
                saveSettingsBtn.click();
            } else {
                showView('settings');
            }
        });

        saveSettingsBtn.addEventListener('click', () => {
            localStorage.setItem('sabnzbdUrl', sabnzbdUrlInput.value.trim());
            localStorage.setItem('sabnzbdApiKey', sabnzbdApiKeyInput.value.trim());
            localStorage.setItem('plexUrl', plexUrlInput.value.trim());
            localStorage.setItem('enablePlexMovies', enablePlexMoviesInput.checked);
            localStorage.setItem('enablePlexTv', enablePlexTvInput.checked);
            localStorage.setItem('sonarrUrl', sonarrUrlInput.value.trim());
            localStorage.setItem('sonarrApiKey', sonarrApiKeyInput.value.trim());
            localStorage.setItem('enableNotifications', enableNotificationsInput.checked);


            cardTitleInputs.forEach(input => {
                localStorage.setItem(`title_${input.dataset.titleKey}`, input.value.trim());
            });

            const order = cardOrderSelects.map(sel => sel.value);
            const uniqueOrder = order.filter(val => val !== 'none');
            if (new Set(uniqueOrder).size !== uniqueOrder.length) {
                 showMessage(cardOrderErrorEl, "Please select a different service for each position (or 'None').", 'error');
                 return;
            }
            showMessage(cardOrderErrorEl, null);
            localStorage.setItem('cardOrder', JSON.stringify(order));


            showMessage(globalMessagesSettingsEl, "Settings saved.", 'success');
            setTimeout(() => {
                showMessage(globalMessagesSettingsEl, null);
                showView('main');
            }, 1500);
        });


        // --- Card Order Settings ---
        function loadCardOrderSettings() {
            const storedOrder = JSON.parse(localStorage.getItem('cardOrder')) || [...defaultCardOrder];
            for(let i = 0; i < cardOrderSelects.length; i++) {
                cardOrderSelects[i].value = storedOrder[i] || (i < defaultCardOrder.length ? defaultCardOrder[i] : 'none');
            }
        }


        function applyCardOrderToDOM() {
            const order = JSON.parse(localStorage.getItem('cardOrder')) || [...defaultCardOrder];
            serviceCardsContainerEl.innerHTML = '';
            order.forEach(serviceKey => {
                if (serviceKey !== 'none' && serviceCardElements[serviceKey]) {
                    serviceCardsContainerEl.appendChild(serviceCardElements[serviceKey]);
                }
            });
        }

        // --- Card Title Settings ---
        function loadCardTitleSettings() {
            cardTitleInputs.forEach(input => {
                const key = `title_${input.dataset.titleKey}`;
                input.value = localStorage.getItem(key) || defaultCardTitles[input.dataset.titleKey] || '';
            });
        }

        function applyCardTitlesToDOM() {
            cardTitleInputs.forEach(input => {
                const serviceKey = input.dataset.titleKey;
                const cardElement = serviceCardElements[serviceKey];
                if (cardElement) {
                    const h2 = cardElement.querySelector('h2');
                    if (h2) {
                        const storedTitle = localStorage.getItem(`title_${serviceKey}`) || defaultCardTitles[serviceKey] || '';
                        h2.textContent = storedTitle;
                    }
                }
            });
        }


        // --- Helper Functions ---
        function showMessage(element, text, type = 'info', displayType = 'block') {
            if (!element) return;
            element.textContent = text;
            element.className = `message ${type}-message`;
            element.style.display = text ? displayType : 'none';
        }

        function generateClientIdentifier() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0 || isNaN(bytes) || bytes === null) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        function formatUnixTimestamp(timestamp) {
            if (!timestamp || timestamp == 0) return 'N/A';
            const date = new Date(timestamp * 1000);
            return date.toLocaleString();
        }

        function getRelativeDateDisplay(dateUtc) {
            if (!dateUtc) return 'N/A';
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);

            const episodeDate = new Date(dateUtc);
            const episodeDateDayStart = new Date(episodeDate.getFullYear(), episodeDate.getMonth(), episodeDate.getDate());

            const timeStr = episodeDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

            if (episodeDateDayStart.getTime() === today.getTime()) {
                return `Today, ${timeStr}`;
            } else if (episodeDateDayStart.getTime() === tomorrow.getTime()) {
                return `Tomorrow, ${timeStr}`;
            } else {
                return `${episodeDate.toLocaleDateString([], { weekday: 'long' })}, ${timeStr}`;
            }
        }


        function clearPlexPolling() {
            if (plexPollingIntervalId) clearInterval(plexPollingIntervalId);
            if (plexPollingTimeoutId) clearTimeout(plexPollingTimeoutId);
            plexPollingIntervalId = null;
            plexPollingTimeoutId = null;
            currentPlexPinId = null;
        }

        // --- Plex PIN Authentication Functions ---
        async function initiatePlexPinAuth() {
            clearPlexPolling();
            plexClientIdentifier = generateClientIdentifier();

            showMessage(plexLinkedStatusEl, null);
            plexPinSection.style.display = 'block';
            showMessage(plexPinStatusEl, "Requesting PIN from Plex.tv...", 'info');
            plexPinCodeEl.textContent = '----';

            try {
                const response = await fetch('https://plex.tv/api/v2/pins.json', {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'X-Plex-Product': X_PLEX_PRODUCT_NAME,
                        'X-Plex-Client-Identifier': plexClientIdentifier
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ errors: [{ message: `HTTP ${response.status}`}]}));
                    throw new Error(`Plex PIN request failed: ${errorData.errors?.[0]?.message || response.statusText}`);
                }
                const data = await response.json();
                if (!data.code || !data.id) {
                    throw new Error('Plex PIN response did not include code or id.');
                }
                currentPlexPinId = data.id;
                plexPinCodeEl.textContent = data.code;
                showMessage(plexPinStatusEl, "PIN obtained. Waiting for you to link on Plex.tv...", 'info');

                plexPollingIntervalId = setInterval(() => pollForPlexToken(data.id), PLEX_POLLING_INTERVAL);
                plexPollingTimeoutId = setTimeout(() => {
                    if (currentPlexPinId === data.id) {
                        showMessage(plexPinStatusEl, "Linking timed out. Please try again.", 'error');
                        clearPlexPolling();
                    }
                }, PLEX_POLLING_TIMEOUT_DURATION);

            } catch (error) {
                console.error('Plex PIN request error:', error);
                showMessage(plexPinStatusEl, `Error getting PIN: ${error.message}`, 'error');
                clearPlexPolling();
            }
        }

        async function pollForPlexToken(pinId) {
            if (!currentPlexPinId || pinId !== currentPlexPinId) return;

            try {
                const response = await fetch(`https://plex.tv/api/v2/pins/${pinId}.json`, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'X-Plex-Product': X_PLEX_PRODUCT_NAME,
                        'X-Plex-Client-Identifier': plexClientIdentifier
                    }
                });

                const data = await response.json();

                if (data.authToken) {
                    clearPlexPolling();
                    plexTokenStoreEl.value = data.authToken;
                    localStorage.setItem('plexToken', data.authToken);
                    plexPinSection.style.display = 'none';
                    showMessage(plexLinkedStatusEl, "Plex account linked successfully!", 'success');
                } else if (!response.ok && response.status === 404) {
                     showMessage(plexPinStatusEl, `PIN invalid or expired. Please try again.`, 'error');
                     clearPlexPolling();
                } else if (!response.ok) {
                    const errorDetail = data.errors?.[0]?.message || `HTTP ${response.status}`;
                    console.warn('Plex PIN poll non-critical error:', errorDetail);
                    showMessage(plexPinStatusEl, "Waiting for you to link on Plex.tv... (checking)", 'info');
                }
                else {
                    showMessage(plexPinStatusEl, "Waiting for you to link on Plex.tv... (checking)", 'info');
                }
            } catch (error) {
                console.error('Plex PIN poll critical error:', error);
                showMessage(plexPinStatusEl, `Error checking PIN: ${error.message}. Retrying...`, 'error');
            }
        }

        function cancelPlexLinkingProcess() {
            clearPlexPolling();
            plexPinSection.style.display = 'none';
            showMessage(plexPinStatusEl, null);
            showMessage(plexLinkedStatusEl, "Plex linking cancelled by user.", 'info');
        }

        // --- Main Fetch Logic ---
        async function handleFetchData(isSabnzbdShowMore = false, forceFullRefresh = false) {
            if (!isSabnzbdShowMore) { // Full refresh or initial load
                allFetchedSabnzbdSlots = [];
                sabnzbdCurrentPageStart = 0;
                sabnzbdListEl.innerHTML = '';
                isInitialSabnzbdFetch = true;
            }

            if (!isSabnzbdShowMore || forceFullRefresh) {
                plexListEl.innerHTML = '';
                plexMoviesListEl.innerHTML = '';
                plexTvListEl.innerHTML = '';

                plexOnDeckData.david = { items: [], showingAll: false }; // Only David now
                plexRecentlyAddedMoviesData = { items: [], showingAll: false };
                plexRecentlyAddedTvData = { items: [], showingAll: false };
                isInitialPlexMoviesFetch = true;
                isInitialPlexTvFetch = true;
            }

            showMessage(sabnzbdErrorEl, null);
            showMessage(plexErrorEl, null);
            showMessage(plexMoviesErrorEl, null);
            showMessage(plexTvErrorEl, null);
            showMessage(sonarrErrorEl, null);

            noServicesConfiguredMessageEl.style.display = 'none';

            const sabUrl = sabnzbdUrlInput.value.trim();
            const sabApiKey = sabnzbdApiKeyInput.value.trim();
            const pUrl = plexUrlInput.value.trim();
            const pToken = plexTokenStoreEl.value.trim();
            const sonUrl = sonarrUrlInput.value.trim();
            const sonApiKey = sonarrApiKeyInput.value.trim();
            const plexMoviesEnabled = enablePlexMoviesInput.checked;
            const plexTvEnabled = enablePlexTvInput.checked;


            let sabConfigured = sabUrl && sabApiKey;
            let plexContinueWatchingConfigured = pUrl && pToken;
            let plexMoviesConfigured = pUrl && pToken && plexMoviesEnabled;
            let plexTvConfigured = pUrl && pToken && plexTvEnabled;
            let sonarrConfigured = sonUrl && sonApiKey;
            let servicesToFetchCount = 0;

            // SABnzbd
            if (sabConfigured) {
                serviceCardElements.sabnzbd.style.display = 'block';
                fetchSabnzbdData(sabUrl, sabApiKey, sabnzbdCurrentPageStart);
                servicesToFetchCount++;
            } else if (sabUrl && !sabApiKey) {
                serviceCardElements.sabnzbd.style.display = 'block';
                showMessage(sabnzbdErrorEl, 'SABnzbd API Key is missing in settings.', 'error');
            } else {
                serviceCardElements.sabnzbd.style.display = 'none';
            }

            // Plex Continue Watching (now only for main user)
            if (plexContinueWatchingConfigured && (!isSabnzbdShowMore || forceFullRefresh)) {
                serviceCardElements.plex.style.display = 'block';
                fetchPlexDataForUser('david'); // Always fetch for 'david'
                servicesToFetchCount++;
            } else if (pUrl && !pToken && (!isSabnzbdShowMore || forceFullRefresh)) {
                serviceCardElements.plex.style.display = 'block';
                showMessage(plexErrorEl, 'Plex account not linked or token unavailable. Please link in settings.', 'error');
            } else if (!plexContinueWatchingConfigured && (!isSabnzbdShowMore || forceFullRefresh)) {
                 serviceCardElements.plex.style.display = 'none';
            }

            // Plex Recently Added Movies
            if (plexMoviesConfigured && (!isSabnzbdShowMore || forceFullRefresh)) {
                serviceCardElements.plexMovies.style.display = 'block';
                fetchPlexRecentlyAdded(pUrl, pToken, 'movie');
                servicesToFetchCount++;
            } else if (plexMoviesEnabled && (!pUrl || !pToken) && (!isSabnzbdShowMore || forceFullRefresh)) {
                serviceCardElements.plexMovies.style.display = 'block';
                showMessage(plexMoviesErrorEl, 'Plex account not linked or token unavailable.', 'error');
            } else if (!plexMoviesEnabled){
                 serviceCardElements.plexMovies.style.display = 'none';
            }

            // Plex Recently Added TV Shows
            if (plexTvConfigured && (!isSabnzbdShowMore || forceFullRefresh)) {
                serviceCardElements.plexTv.style.display = 'block';
                fetchPlexRecentlyAdded(pUrl, pToken, 'tv');
                servicesToFetchCount++;
            } else if (plexTvEnabled && (!pUrl || !pToken) && (!isSabnzbdShowMore || forceFullRefresh)) {
                serviceCardElements.plexTv.style.display = 'block';
                showMessage(plexTvErrorEl, 'Plex account not linked or token unavailable.', 'error');
            } else if(!plexTvEnabled) {
                 serviceCardElements.plexTv.style.display = 'none';
            }


            // Sonarr
            if (sonarrConfigured && !isSabnzbdShowMore) {
                serviceCardElements.sonarr.style.display = 'block';
                showingAllSonarrEpisodes = false;
                fetchSonarrCalendar(sonUrl, sonApiKey);
                servicesToFetchCount++;
            } else if (sonUrl && !sonApiKey && !isSabnzbdShowMore) {
                serviceCardElements.sonarr.style.display = 'block';
                showMessage(sonarrErrorEl, 'Sonarr API Key is missing in settings.', 'error');
            } else if(!sonarrConfigured && !isSabnzbdShowMore) {
                serviceCardElements.sonarr.style.display = 'none';
            }

            if(servicesToFetchCount === 0 && (!sabUrl && !pUrl && !sonUrl)) {
                 noServicesConfiguredMessageEl.style.display = 'block';
            } else if (servicesToFetchCount === 0 && (sabUrl || pUrl || sonUrl)) {
                noServicesConfiguredMessageEl.style.display = 'none';
            }
            setTimeout(checkScrollIndicators, 500);
        }

        // --- SABnzbd Functions ---
        async function fetchSabnzbdData(baseUrl, apiKey, start = 0) {
            showMessage(sabnzbdLoadingEl, "Loading...", 'loading');
            if (start === 0) showMessage(sabnzbdErrorEl, null);

            const apiUrl = `${baseUrl.replace(/\/$/, "")}/api?mode=history&start=${start}&limit=${SABNZBD_ITEMS_PER_PAGE}&output=json&apikey=${apiKey}`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`SABnzbd API request failed: ${response.status} ${response.statusText}`);
                const data = await response.json();
                if (data.error) throw new Error(`SABnzbd API error: ${data.error}`);

                if (data.history && data.history.slots) {
                    const newSlots = data.history.slots;
                    if (newSlots.length > 0) {
                        const currentTopItemSignature = newSlots[0].nzo_id;
                        if (!isInitialSabnzbdFetch && lastSeenSabnzbdItemSignature !== currentTopItemSignature) {
                             if(enableNotificationsInput.checked) showToast('New download(s) in SABnzbd.', 'SABnzbd Update', 'info');
                        }
                        lastSeenSabnzbdItemSignature = currentTopItemSignature;
                    }
                    if (start === 0) { // Only reset for a completely new fetch, not "show more"
                        allFetchedSabnzbdSlots = [];
                        isInitialSabnzbdFetch = false;
                    }

                    allFetchedSabnzbdSlots = allFetchedSabnzbdSlots.concat(newSlots);
                    renderSabnzbdData(allFetchedSabnzbdSlots);
                    sabnzbdCurrentPageStart = allFetchedSabnzbdSlots.length;
                    showMoreSabnzbdBtn.style.display = newSlots.length === SABNZBD_ITEMS_PER_PAGE ? 'block' : 'none';
                } else {
                    showMoreSabnzbdBtn.style.display = 'none';
                    if (start === 0) renderSabnzbdData([]);
                    if (start === 0) isInitialSabnzbdFetch = false;
                }
            } catch (error) {
                console.error('SABnzbd fetch error:', error);
                showMessage(sabnzbdErrorEl, `Error fetching SABnzbd data: ${error.message}.`, 'error');
                showMoreSabnzbdBtn.style.display = 'none';
                if (start === 0) isInitialSabnzbdFetch = false;
            } finally {
                showMessage(sabnzbdLoadingEl, null);
                checkScrollIndicators();
            }
        }

        function renderSabnzbdData(slotsToRender) {
            sabnzbdListEl.innerHTML = '';
            if (slotsToRender.length === 0) {
                sabnzbdListEl.innerHTML = '<li class="sab-item"><div class="item-content">No download history found.</div></li>';
                return;
            }
            slotsToRender.forEach(item => {
                const li = document.createElement('li');
                li.className = 'sab-item';
                li.innerHTML = `
                    <div class="item-content">
                        <div class="item-title-main">${item.name || item.nzb_name || 'N/A'}</div>
                        <div class="item-meta-info">
                            Size: ${formatBytes(item.bytes)} |
                            Completed: ${formatUnixTimestamp(item.completed_time || item.completed)}
                        </div>
                    </div>
                `;
                sabnzbdListEl.appendChild(li);
            });
        }
        showMoreSabnzbdBtn.addEventListener('click', () => {
             const sabUrl = sabnzbdUrlInput.value.trim();
             const sabApiKey = sabnzbdApiKeyInput.value.trim();
             if (sabUrl && sabApiKey) {
                handleFetchData(true); // Pass true to indicate it's a "show more" for SAB
             }
        });


        // --- Plex Functions (Continue Watching) ---
        async function fetchPlexDataForUser(userKey = 'david') {
            const baseUrl = plexUrlInput.value.trim();
            const token = plexTokenStoreEl.value.trim();

            if (!baseUrl || !token) {
                showMessage(plexErrorEl, 'Plex URL or Token missing.', 'error');
                renderPlexDataDisplay(userKey);
                return;
            }

            plexOnDeckData[userKey] = { items: [], showingAll: false };

            showMessage(plexLoadingEl, `Loading Continue Watching...`, 'loading');
            showMessage(plexErrorEl, null);

            const apiUrl = `${baseUrl.replace(/\/$/, "")}/library/onDeck`;
            const headers = {
                'X-Plex-Token': token,
                'Accept': 'application/json'
            };

            try {
                const response = await fetch(apiUrl, { headers: headers });
                if (!response.ok) {
                     const errorText = await response.text().catch(() => `HTTP ${response.status}`);
                    throw new Error(`Plex API request failed: ${response.status} ${response.statusText}. Response: ${errorText.substring(0,150)}`);
                }
                const data = await response.json();
                plexOnDeckData[userKey].items = (data.MediaContainer && data.MediaContainer.Metadata) ? data.MediaContainer.Metadata : [];
                renderPlexDataDisplay(userKey);
            } catch (error) {
                console.error(`Plex fetch error for ${userKey}:`, error);
                showMessage(plexErrorEl, `Error fetching Plex data: ${error.message}.`, 'error');
                plexOnDeckData[userKey] = { items: [], showingAll: false };
                renderPlexDataDisplay(userKey);
            } finally {
                showMessage(plexLoadingEl, null);
                checkScrollIndicators();
            }
        }

        function renderPlexDataDisplay(userKey) {
            plexListEl.innerHTML = '';
            loadMorePlexBtn.style.display = 'none';
            const userData = plexOnDeckData[userKey];

            if (!userData || !userData.items || userData.items.length === 0) {
                const li = document.createElement('li');
                li.textContent = `Nothing in Continue Watching.`;
                li.className = 'message info-message';
                plexListEl.appendChild(li);
                return;
            }

            const itemsToDisplay = userData.showingAll ? userData.items : userData.items.slice(0, PLEX_INITIAL_DISPLAY_COUNT);

            itemsToDisplay.forEach(item => {
                const li = document.createElement('li');
                li.className = 'plex-item';
                let titleText = item.title || 'Unknown Title';
                let posterKey = item.thumb;
                if (item.type === 'episode') {
                    titleText = item.grandparentTitle || 'TV Show';
                    if (item.grandparentThumb) posterKey = item.grandparentThumb;
                } else if (item.type === 'movie') {
                    titleText = `${item.title} (${item.year || 'N/A'})`;
                }
                const thumbnailUrl = posterKey ? `${plexUrlInput.value.trim().replace(/\/$/, "")}${posterKey}?X-Plex-Token=${plexTokenStoreEl.value.trim()}` : `https://placehold.co/200x300/2c3e50/ecf0f1?text=No+Art`;
                const progressPercent = (item.viewOffset && item.duration) ? (item.viewOffset / item.duration) * 100 : 0;
                li.innerHTML = `
                    <img src="${thumbnailUrl}" alt="Poster for ${titleText}" class="plex-item-poster" onerror="this.onerror=null;this.src='https://placehold.co/200x300/2c3e50/ecf0f1?text=No+Art';">
                    <div class="plex-item-info">
                        <div class="plex-item-title" title="${titleText}">${titleText}</div>
                        ${item.viewOffset && item.duration ? `
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${progressPercent.toFixed(1)}%;"></div>
                        </div>
                        <div class="item-meta">${Math.round(item.viewOffset / 60000)}/${Math.round(item.duration / 60000)} min</div>
                        ` : ''}
                    </div>
                `;
                plexListEl.appendChild(li);
            });

            if (!userData.showingAll && userData.items.length > PLEX_INITIAL_DISPLAY_COUNT) {
                loadMorePlexBtn.style.display = 'block';
            }
        }

        loadMorePlexBtn.addEventListener('click', () => {
            if (plexOnDeckData['david']) {
                plexOnDeckData['david'].showingAll = true;
                renderPlexDataDisplay('david');
            }
        });

        // --- Plex Recently Added Functions ---
        async function fetchPlexRecentlyAdded(baseUrl, token, itemType) {
            const loadingEl = itemType === 'movie' ? plexMoviesLoadingEl : plexTvLoadingEl;
            const errorEl = itemType === 'movie' ? plexMoviesErrorEl : plexTvErrorEl;
            const dataStore = itemType === 'movie' ? plexRecentlyAddedMoviesData : plexRecentlyAddedTvData;
            const lastSeenKey = itemType === 'movie' ? 'lastSeenPlexMovieItemSignature' : 'lastSeenPlexTvShowItemSignature';
            const isInitialFetchKey = itemType === 'movie' ? 'isInitialPlexMoviesFetch' : 'isInitialPlexTvFetch';

            showMessage(loadingEl, "Loading...", 'loading');
            showMessage(errorEl, null);

            // Determine the API endpoint and processing based on itemType
            let apiItemTypeValue;
            if (itemType === 'movie') {
                apiItemTypeValue = '1'; // Movies
            } else if (itemType === 'tv') {
                apiItemTypeValue = '4'; // Episodes, to correctly capture shows with new episodes
            } else {
                console.error("Unknown itemType for fetchPlexRecentlyAdded:", itemType);
                return;
            }

            const apiUrl = `${baseUrl.replace(/\/$/, "")}/library/recentlyAdded?type=${apiItemTypeValue}&X-Plex-Container-Size=50`;

            try {
                const response = await fetch(apiUrl, { headers: { 'X-Plex-Token': token, 'Accept': 'application/json' }});
                if (!response.ok) {
                    const errorText = await response.text().catch(() => `HTTP ${response.status}`);
                    throw new Error(`Plex Recently Added (${itemType}) API request failed: ${response.status} ${response.statusText}. Response: ${errorText.substring(0,150)}`);
                }
                const apiData = await response.json();

                let processedItems = [];
                if (apiData.MediaContainer && apiData.MediaContainer.Metadata) {
                    if (itemType === 'movie') {
                        // For movies, Plex items are already what we need.
                        processedItems = apiData.MediaContainer.Metadata.filter(item => item.type === 'movie');
                    } else if (itemType === 'tv') {
                        // We fetched episodes (type=4), now group them by show
                        const seriesMap = new Map();
                        apiData.MediaContainer.Metadata.forEach(episode => {
                            // Ensure it's an episode and has parent series info
                            if (episode.type === 'episode' && episode.grandparentRatingKey) {
                                const seriesKey = episode.grandparentRatingKey;
                                const seriesTitle = episode.grandparentTitle;
                                const seriesThumb = episode.grandparentThumb;
                                const episodeAddedAt = episode.addedAt; // Timestamp of this specific episode

                                // If series is not in map, or this episode is newer than the one stored for the series
                                // This ensures 'addedAt' for the series in the map reflects its most recent episode
                                if (!seriesMap.has(seriesKey) || episodeAddedAt > seriesMap.get(seriesKey).addedAt) {
                                    seriesMap.set(seriesKey, {
                                        title: seriesTitle,
                                        thumb: seriesThumb,
                                        type: 'show', // We always represent it as a show in our final list
                                        addedAt: episodeAddedAt, // Use the episode's addedAt for sorting
                                        ratingKey: seriesKey
                                    });
                                }
                            }
                        });
                        // Convert map values to an array and sort by the latest episode's addedAt timestamp
                        processedItems = Array.from(seriesMap.values()).sort((a,b) => (b.addedAt || 0) - (a.addedAt || 0));
                    }
                }

                if (processedItems.length > 0) {
                    const currentTopItemSignature = processedItems[0].ratingKey || processedItems[0].title;
                    if (!window[isInitialFetchKey] && window[lastSeenKey] !== currentTopItemSignature) {
                        if(enableNotificationsInput.checked) showToast(`New ${itemType === 'movie' ? 'movie(s)' : 'TV show(s)/episodes(s)'} added to Plex.`, `Plex ${itemType.toUpperCase()} Update`, 'info');
                    }
                    window[lastSeenKey] = currentTopItemSignature;
                } else if (window[lastSeenKey] !== null) {
                     window[lastSeenKey] = null;
                }
                window[isInitialFetchKey] = false;


                dataStore.items = processedItems;
                dataStore.showingAll = false;
                renderPlexRecentlyAdded(itemType);
            } catch (error) {
                console.error(`Plex Recently Added (${itemType}) fetch error:`, error);
                showMessage(errorEl, `Error fetching recently added ${itemType === 'movie' ? 'movies' : 'TV content'}: ${error.message}.`, 'error');
                dataStore.items = [];
                renderPlexRecentlyAdded(itemType);
                window[isInitialFetchKey] = false;
            } finally {
                showMessage(loadingEl, null);
                checkScrollIndicators();
            }
        }

        function renderPlexRecentlyAdded(itemType) {
            const listEl = itemType === 'movie' ? plexMoviesListEl : plexTvListEl;
            const dataStore = itemType === 'movie' ? plexRecentlyAddedMoviesData : plexRecentlyAddedTvData;
            const loadMoreBtn = itemType === 'movie' ? loadMorePlexMoviesBtn : loadMorePlexTvBtn;

            listEl.innerHTML = '';
            loadMoreBtn.style.display = 'none';

            if (!dataStore || !dataStore.items || dataStore.items.length === 0) {
                const li = document.createElement('li');
                li.textContent = `No recently added ${itemType === 'movie' ? 'movies' : 'TV shows'} found.`;
                li.className = 'message info-message';
                listEl.appendChild(li);
                return;
            }

            const itemsToDisplay = dataStore.showingAll ? dataStore.items : dataStore.items.slice(0, PLEX_INITIAL_DISPLAY_COUNT);

            itemsToDisplay.forEach(item => {
                const li = document.createElement('li');
                li.className = 'plex-item';

                let titleText = item.title || 'Unknown Title';
                let posterKey = item.thumb;

                // For movies, add year. For TV shows (already processed to show level), title is fine.
                if (item.type === 'movie' && item.year) {
                    titleText = `${item.title} (${item.year})`;
                }


                const thumbnailUrl = posterKey ? `${plexUrlInput.value.trim().replace(/\/$/, "")}${posterKey}?X-Plex-Token=${plexTokenStoreEl.value.trim()}` : `https://placehold.co/200x300/2c3e50/ecf0f1?text=No+Art`;

                li.innerHTML = `
                    <img src="${thumbnailUrl}" alt="Poster for ${titleText}" class="plex-item-poster" onerror="this.onerror=null;this.src='https://placehold.co/200x300/2c3e50/ecf0f1?text=No+Art';">
                    <div class="plex-item-info">
                        <div class="plex-item-title" title="${titleText}">${titleText}</div>
                    </div>
                `;
                listEl.appendChild(li);
            });

            if (!dataStore.showingAll && dataStore.items.length > PLEX_INITIAL_DISPLAY_COUNT) {
                loadMoreBtn.style.display = 'block';
            }
        }

        loadMorePlexMoviesBtn.addEventListener('click', () => {
            plexRecentlyAddedMoviesData.showingAll = true;
            renderPlexRecentlyAdded('movie');
        });
        loadMorePlexTvBtn.addEventListener('click', () => {
            plexRecentlyAddedTvData.showingAll = true;
            renderPlexRecentlyAdded('tv');
        });



        // --- Sonarr Functions ---
        async function fetchSonarrCalendar(baseUrl, apiKey) {
            showMessage(sonarrLoadingEl, "Loading...", 'loading');
            showMessage(sonarrErrorEl, null);
            const startDate = new Date();
            const endDate = new Date();
            endDate.setDate(startDate.getDate() + 7);
            const startStr = startDate.toISOString().split('T')[0];
            const endStr = endDate.toISOString().split('T')[0];

            const apiUrl = `${baseUrl.replace(/\/$/, "")}/api/v3/calendar?apikey=${apiKey}&unmonitored=false&start=${startStr}&end=${endStr}&includeSeries=true`;

            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`Sonarr API request failed: ${response.status} ${response.statusText}`);
                const data = await response.json();
                if (Array.isArray(data)) {
                    allFetchedSonarrEpisodes = data.sort((a, b) => new Date(a.airDateUtc) - new Date(b.airDateUtc));
                    showingAllSonarrEpisodes = true;
                    renderSonarrCalendarDisplay();
                } else {
                     throw new Error('Sonarr API response format unexpected (expected an array).');
                }
            } catch (error) {
                console.error('Sonarr fetch error:', error);
                showMessage(sonarrErrorEl, `Error fetching Sonarr calendar: ${error.message}.`, 'error');
            } finally {
                showMessage(sonarrLoadingEl, null);
                checkScrollIndicators();
            }
        }

        function renderSonarrCalendarDisplay() {
            sonarrCalendarListEl.innerHTML = '';
            loadMoreSonarrBtn.style.display = 'none';

            const sonarrBaseUrl = sonarrUrlInput.value.trim();
            const sonarrApiKey = sonarrApiKeyInput.value.trim();

            if (!allFetchedSonarrEpisodes || allFetchedSonarrEpisodes.length === 0) {
                sonarrCalendarListEl.innerHTML = '<li class="calendar-item"><div class="item-content">No upcoming episodes in the calendar for the next 7 days.</div></li>';
                return;
            }

            // Group episodes by series and air date (ignoring time for grouping by day)
            const groupedEpisodes = allFetchedSonarrEpisodes.reduce((acc, ep) => {
                const airDateObj = new Date(ep.airDateUtc);
                const airDateStr = new Date(airDateObj.getFullYear(), airDateObj.getMonth(), airDateObj.getDate()).toISOString().split('T')[0];
                const seriesId = ep.series?.id || 'unknownSeries';
                const groupKey = `${seriesId}-${airDateStr}`;

                if (!acc[groupKey]) {
                    acc[groupKey] = {
                        series: ep.series,
                        airDateUtcForSort: ep.airDateUtc,
                        airDateDisplay: getRelativeDateDisplay(ep.airDateUtc),
                        episodes: []
                    };
                }
                acc[groupKey].episodes.push(ep);
                return acc;
            }, {});

            const displayGroups = Object.values(groupedEpisodes).sort((a,b) => new Date(a.airDateUtcForSort) - new Date(b.airDateUtcForSort));

            displayGroups.forEach(group => {
                const li = document.createElement('li');
                li.className = 'calendar-item';

                const seriesTitle = group.series && group.series.title ? group.series.title : 'Unknown Series';

                let posterUrl = 'https://placehold.co/50x75/2c3e50/ecf0f1?text=No+Img';
                if (group.series && group.series.images && Array.isArray(group.series.images)) {
                    let posterImage = group.series.images.find(img => img.coverType === 'poster' && (img.remoteUrl || img.url));
                    if (!posterImage) posterImage = group.series.images.find(img => img.coverType === 'banner' && (img.remoteUrl || img.url));
                    if (!posterImage) posterImage = group.series.images.find(img => (img.remoteUrl || img.url));

                    if (posterImage) {
                        let imagePath = posterImage.remoteUrl || posterImage.url;
                        if (imagePath) {
                            if (imagePath.startsWith('http://') || imagePath.startsWith('https://')) {
                                posterUrl = imagePath;
                            } else {
                                if (imagePath.startsWith('/')) imagePath = imagePath.substring(1);
                                posterUrl = `${sonarrBaseUrl.replace(/\/$/, "")}/${imagePath}?apikey=${sonarrApiKey}`;
                            }
                        }
                    }
                }

                let episodeDetailsHtml = '';
                if (group.episodes.length === 1) {
                    const ep = group.episodes[0];
                    const episodeTitleText = ep.title || 'Unknown Episode';
                    const seasonNum = String(ep.seasonNumber || 0).padStart(2,'0');
                    const episodeNum = String(ep.episodeNumber || 0).padStart(2,'0');
                    const specificAirTime = new Date(ep.airDateUtc).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
                     episodeDetailsHtml = `<div class="calendar-episode-summary">S${seasonNum}E${episodeNum} - ${episodeTitleText} (${specificAirTime})</div>`;
                } else if (group.episodes.length > 1) {
                    // Sort episodes within the group by episode number for correct range display
                    group.episodes.sort((a,b) => (a.seasonNumber - b.seasonNumber) || (a.episodeNumber - b.episodeNumber));
                    const firstEp = group.episodes[0];
                    const lastEp = group.episodes[group.episodes.length - 1];
                    const seasonNum = String(firstEp.seasonNumber || 0).padStart(2,'0');
                    const firstEpTime = new Date(firstEp.airDateUtc).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });

                    if (firstEp.seasonNumber === lastEp.seasonNumber &&
                        (lastEp.episodeNumber - firstEp.episodeNumber + 1) === group.episodes.length) { // Sequential check
                        episodeDetailsHtml = `<div class="calendar-episode-summary">S${seasonNum} Episodes ${firstEp.episodeNumber} - ${lastEp.episodeNumber} (from ${firstEpTime})</div>`;
                    } else { // Not perfectly sequential or different seasons, list them
                         group.episodes.forEach(ep => {
                            const episodeTitleText = ep.title || 'Unknown Episode';
                            const sNum = String(ep.seasonNumber || 0).padStart(2,'0');
                            const eNum = String(ep.episodeNumber || 0).padStart(2,'0');
                            const specificAirTime = new Date(ep.airDateUtc).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
                            episodeDetailsHtml += `<div class="calendar-episode-summary">S${sNum}E${eNum} - ${episodeTitleText} (${specificAirTime})</div>`;
                        });
                    }
                }


                li.innerHTML = `
                    <img src="${posterUrl}" alt="Poster for ${seriesTitle}" class="calendar-item-poster" onerror="this.onerror=null;this.src='https://placehold.co/50x75/2c3e50/ecf0f1?text=No+Img';">
                    <div class="item-content">
                        <div class="calendar-item-date">${group.airDateDisplay.split(',')[0]}</div> <div class="item-title-main">${seriesTitle}</div>
                        ${episodeDetailsHtml}
                    </div>
                `;
                sonarrCalendarListEl.appendChild(li);
            });
        }

        // --- Auto Refresh ---
        function startAutoRefresh() {
            if (autoRefreshTimerId) clearInterval(autoRefreshTimerId);
            autoRefreshTimerId = setInterval(() => {
                if (currentView === 'main') {
                    const sabUrl = sabnzbdUrlInput.value.trim();
                    const sabApiKey = sabnzbdApiKeyInput.value.trim();
                    const pUrl = plexUrlInput.value.trim();
                    const pToken = plexTokenStoreEl.value.trim();
                    const sonUrl = sonarrUrlInput.value.trim();
                    const sonApiKey = sonarrApiKeyInput.value.trim();

                    if ((sabUrl && sabApiKey) || (pUrl && pToken) || (sonUrl && sonApiKey)) {
                        console.log("Auto-refreshing data at " + new Date().toLocaleTimeString());
                        handleFetchData(false, true);
                    }
                }
            }, AUTO_REFRESH_INTERVAL);
        }

        // --- Mobile Accordion & Scroll Indicators ---
        function initializeMobileAccordion() {
            const cards = document.querySelectorAll('#mainView .service-card');
            let firstVisibleCardForMobile = null;

            cards.forEach(card => {
                const contentWrapper = card.querySelector('.card-content-wrapper');
                const title = card.querySelector('h2');
                const scrollIndicator = card.querySelector('.scroll-indicator-container');

                if (!contentWrapper || !title) {
                    return;
                }

                if(scrollIndicator) scrollIndicator.style.display = 'none';

                if (window.innerWidth <= 768) {
                    contentWrapper.style.display = 'none';
                    contentWrapper.style.maxHeight = 'none';
                    contentWrapper.style.overflowY = 'visible';
                    card.classList.remove('expanded');
                    title.style.cursor = 'pointer';
                    title.removeEventListener('click', handleCardTitleClick);
                    title.addEventListener('click', handleCardTitleClick);

                    if (!firstVisibleCardForMobile && window.getComputedStyle(card).display !== 'none') {
                        firstVisibleCardForMobile = card;
                    }
                } else {
                    contentWrapper.style.display = 'block';
                    if (!contentWrapper.classList.contains('no-scroll')) {
                        contentWrapper.style.maxHeight = '550px';
                        contentWrapper.style.overflowY = 'auto';
                        if (scrollIndicator && contentWrapper.scrollHeight > contentWrapper.clientHeight) {
                            scrollIndicator.style.display = 'flex';
                        }
                    }
                    card.classList.remove('expanded');
                    title.style.cursor = 'default';
                    title.removeEventListener('click', handleCardTitleClick);
                }
            });

            if (window.innerWidth <= 768 && firstVisibleCardForMobile) {
                const firstContentWrapper = firstVisibleCardForMobile.querySelector('.card-content-wrapper');
                if (firstContentWrapper) {
                    firstContentWrapper.style.display = 'block';
                }
                firstVisibleCardForMobile.classList.add('expanded');
            }
        }

        function handleCardTitleClick(event) {
            if (window.innerWidth > 768) return;

            const clickedCard = event.target.closest('.service-card');
            if (!clickedCard) return;

            const contentToToggle = clickedCard.querySelector('.card-content-wrapper');
            if (!contentToToggle) return;

            const isCurrentlyExpanded = clickedCard.classList.contains('expanded');

            document.querySelectorAll('#mainView .service-card.expanded').forEach(expandedCard => {
                if (expandedCard !== clickedCard) {
                    const otherContent = expandedCard.querySelector('.card-content-wrapper');
                    if(otherContent) otherContent.style.display = 'none';
                    expandedCard.classList.remove('expanded');
                }
            });

            if (isCurrentlyExpanded) {
                contentToToggle.style.display = 'none';
                clickedCard.classList.remove('expanded');
            } else {
                contentToToggle.style.display = 'block';
                clickedCard.classList.add('expanded');
            }
        }

        function checkScrollIndicators() {
            if (window.innerWidth > 768) {
                document.querySelectorAll('#mainView .service-card .card-content-wrapper').forEach(wrapper => {
                    const indicatorContainer = wrapper.parentElement.querySelector('.scroll-indicator-container');
                    if (indicatorContainer) {
                        const isScrollable = wrapper.scrollHeight > wrapper.clientHeight;
                        const atBottom = wrapper.scrollHeight - wrapper.scrollTop <= wrapper.clientHeight + 5;

                        if (isScrollable && !atBottom) {
                            indicatorContainer.style.display = 'flex';
                        } else {
                            indicatorContainer.style.display = 'none';
                        }
                    }
                });
            } else {
                 document.querySelectorAll('#mainView .service-card .scroll-indicator-container').forEach(indicatorContainer => {
                    if(indicatorContainer) indicatorContainer.style.display = 'none';
                 });
            }
        }
        document.querySelectorAll('#mainView .service-card .card-content-wrapper').forEach(wrapper => {
            wrapper.addEventListener('scroll', () => checkScrollIndicators());
        });


        // --- Pushover Toast and History ---

        function showToast(message, title = "Notification", type = "info", duration = 5000) {
            if (!enableNotificationsInput.checked) return;

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            let toastHTML = '';
            if (title) {
                toastHTML += `<div class="toast-title">${title}</div>`;
            }
            toastHTML += `<div>${message}</div>`;
            toast.innerHTML = toastHTML;

            toastContainer.appendChild(toast);

            pushoverMessagesHistory.unshift({ title, message, type, timestamp: new Date() });
            if (pushoverMessagesHistory.length > 20) {
                pushoverMessagesHistory.pop();
            }
            localStorage.setItem('pushoverHistory', JSON.stringify(pushoverMessagesHistory));


            setTimeout(() => {
                toast.classList.add('show');
            }, 100);

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentElement) {
                         toast.parentElement.removeChild(toast);
                    }
                }, 500);
            }, duration);
        }

        function renderPushoverHistory() {
            pushoverHistoryListEl.innerHTML = '';
            const history = JSON.parse(localStorage.getItem('pushoverHistory')) || [];

            if (history.length === 0) {
                noPushoverHistoryEl.style.display = 'block';
                clearNotificationHistoryBtn.style.display = 'none';
                return;
            }
            noPushoverHistoryEl.style.display = 'none';
            clearNotificationHistoryBtn.style.display = 'inline-block';


            history.forEach(item => {
                const li = document.createElement('li');
                li.className = 'history-item';
                li.innerHTML = `
                    <div class="history-item-title">${item.title || 'Notification'} (${item.type})</div>
                    <div class="history-item-message">${item.message}</div>
                    <div class="history-item-time">${new Date(item.timestamp).toLocaleString()}</div>
                `;
                pushoverHistoryListEl.appendChild(li);
            });
        }

        pushoverHistoryBtn.addEventListener('click', () => {
            renderPushoverHistory();
            pushoverHistoryModal.style.display = 'flex';
        });
        closePushoverHistoryModalBtn.addEventListener('click', () => {
            pushoverHistoryModal.style.display = 'none';
        });
        clearNotificationHistoryBtn.addEventListener('click', () => {
            pushoverMessagesHistory = [];
            localStorage.removeItem('pushoverHistory');
            renderPushoverHistory();
        });
        pushoverHistoryModal.addEventListener('click', (event) => {
            if (event.target === pushoverHistoryModal) {
                pushoverHistoryModal.style.display = 'none';
            }
        });
        if(testNotificationBtn) {
            testNotificationBtn.addEventListener('click', () => {
                showToast("This is a test notification!", "Test Notification", "info");
            });
        }

        // --- Scroll Page Button ---
        if (scrollPageBtn) {
            scrollPageBtn.addEventListener('click', () => {
                const atTop = window.scrollY < 50;
                if (atTop) {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                } else {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
            window.addEventListener('scroll', updateScrollButtonIcon);
        }
        function updateScrollButtonIcon() {
            if (!scrollPageBtn) return;
            const atTop = window.scrollY < 50;
            scrollPageBtn.innerHTML = atTop ? scrollDownSvg : scrollUpSvg;
            scrollPageBtn.title = atTop ? "Scroll to Bottom" : "Scroll to Top";
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            const storedSabUrl = localStorage.getItem('sabnzbdUrl');
            const storedSabApiKey = localStorage.getItem('sabnzbdApiKey');
            const storedPlexUrl = localStorage.getItem('plexUrl');
            const storedPlexToken = localStorage.getItem('plexToken');
            const storedEnablePlexMovies = localStorage.getItem('enablePlexMovies') === 'true';
            const storedEnablePlexTv = localStorage.getItem('enablePlexTv') === 'true';
            const storedSonarrUrl = localStorage.getItem('sonarrUrl');
            const storedSonarrApiKey = localStorage.getItem('sonarrApiKey');
            const storedEnableNotifications = localStorage.getItem('enableNotifications');
            pushoverMessagesHistory = JSON.parse(localStorage.getItem('pushoverHistory')) || [];

            cardTitleInputs.forEach(input => {
                const key = `title_${input.dataset.titleKey}`;
                input.value = localStorage.getItem(key) || defaultCardTitles[input.dataset.titleKey] || '';
            });


            sabnzbdUrlInput.value = storedSabUrl || 'http://media.local:8080/';
            sabnzbdApiKeyInput.value = storedSabApiKey || '55af5171b46143b1872ed07b622262df';
            plexUrlInput.value = storedPlexUrl || 'http://192.168.1.20:32400';
            enablePlexMoviesInput.checked = storedEnablePlexMovies;
            enablePlexTvInput.checked = storedEnablePlexTv;
            sonarrUrlInput.value = storedSonarrUrl || 'http://media.local:8989/';
            sonarrApiKeyInput.value = storedSonarrApiKey || 'd5c8a95b50ca4eb6ac7c34d64a1b5069';
            enableNotificationsInput.checked = storedEnableNotifications === null ? true : storedEnableNotifications === 'true';

            if (storedPlexToken) {
                plexTokenStoreEl.value = storedPlexToken;
                showMessage(plexLinkedStatusEl, "Plex account previously linked.", 'success', 'block');
            }

            plexClientIdentifier = generateClientIdentifier();
            loadCardOrderSettings();
            showView('main');
            window.addEventListener('resize', () => {
                if (currentView === 'main') {
                    initializeMobileAccordion();
                }
                updateScrollButtonIcon();
                checkScrollIndicators();
            });
            updateScrollButtonIcon();
            checkScrollIndicators();
        });

        // Event listeners for Plex PIN Auth
        getPlexPinBtn.addEventListener('click', initiatePlexPinAuth);
        cancelPlexPinBtn.addEventListener('click', cancelPlexLinkingProcess);

    </script>
</body>
</html>
